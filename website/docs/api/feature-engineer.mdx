---
id: feature-engineer
title: Traitement des Features
hide_title: true
sidebar_label: Features
---

<!-- Complet for v0.1.0-alpha release -->

import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { faWandSparkles, faFileCode, faObjectGroup, faBook, faArrowRight, faExclamationTriangle, faCogs, faCubes } from '@fortawesome/free-solid-svg-icons'
import Admonition from '@theme/Admonition';

## <FontAwesomeIcon icon={faCubes} /> `peak_detector.py` & `feature_engineering.py`

Cette √©tape est le c≈ìur de l'approche "physique" du pipeline. Elle est g√©r√©e par deux modules qui travaillent en tandem : `peak_detector.py` et `feature_engineering.py`. Leur r√¥le combin√© est de transformer un spectre normalis√© en un vecteur de features num√©riques.

### <FontAwesomeIcon icon={faCogs} /> Workflow du Traitement

<div style={{textAlign: 'center', backgroundColor: 'var(--ifm-background-color-secondary)', padding: '1rem', borderRadius: 'var(--ifm-card-border-radius)'}}>

```mermaid
flowchart LR
    SPECTRE["Spectre normalis√©"] --> DETECT["D√©tection des pics<br>(PeakDetector)"]
    DETECT --> MATCH["Matching des raies cibles"]
    MATCH --> VECT["Vectorisation<br>(FeatureEngineer)"]
    VECT --> FEATURES["Vecteur de features<br>[0.0, 6565.2, ...]"]
```
</div>


1.  **`PeakDetector`** : Identifie les raies d'absorption.
2.  **`FeatureEngineer`** : Convertit ces d√©tections en un vecteur num√©rique.

## <FontAwesomeIcon icon={faObjectGroup} /> Classe `PeakDetector`

Cette classe recherche les minima locaux significatifs dans un spectre et les associe √† des raies spectrales connues.

<details>
<summary>D√©tails des attributs et de la configuration</summary>
<div>
<p>Le <code>PeakDetector</code> est initialis√© avec des param√®tres par d√©faut qui contr√¥lent sa sensibilit√© :</p>
<ul>
<li><strong><code>prominence</code></strong> (d√©faut: 1.4) : C'est le param√®tre le plus important, h√©rit√© de <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.find_peaks.html" target="_blank">scipy.signal.find_peaks</a>. Il d√©finit l'amplitude minimale qu'un pic doit avoir par rapport √† son entourage pour √™tre consid√©r√© comme significatif. Une faible valeur d√©tectera plus de pics (potentiellement du bruit), une valeur √©lev√©e ne gardera que les raies les plus profondes.</li>
<li><strong><code>window</code></strong> (d√©faut: 30 √Ö) : D√©finit la fen√™tre de tol√©rance autour d'une raie th√©orique pour le matching.</li>
<li><strong><code>target_lines</code></strong> : Un dictionnaire des raies que nous cherchons (HŒ±, HŒ≤, CaII K, CaII H), choisies pour leur fort pouvoir discriminant dans la classification stellaire.</li>
</ul>
</div>
</details>

### M√©thodes Principales

#### `detect_peaks(wavelength, flux)`
-   **R√¥le :** D√©tecte tous les minima locaux (pics d'absorption) dans le spectre.
-   **Logique :** Utilise `scipy.signal.find_peaks` sur le flux invers√© (`-flux`).
-   **Retourne :** Les indices des pics d√©tect√©s.

#### `match_known_lines(peak_wavelengths)`
-   **R√¥le :** Compare les longueurs d'onde des pics d√©tect√©s √† un dictionnaire de raies cibles (HŒ±, HŒ≤, etc.).
-   **Retourne :** Un dictionnaire associant chaque nom de raie cible √† la longueur d'onde du pic le plus proche trouv√© (ou `None` si aucun pic n'est trouv√© dans la fen√™tre de tol√©rance).

#### `analyze_spectrum(wavelength, flux)`
-   **R√¥le :** Orchestre le processus complet en appelant `detect_peaks` puis `match_known_lines`.
-   **C'est la m√©thode principale √† utiliser.**

## <FontAwesomeIcon icon={faObjectGroup} /> Classe `FeatureEngineer`

Cette classe prend le r√©sultat du `PeakDetector` et le transforme en un vecteur de features simple.

### M√©thodes Principales

#### `extract_features(matched_lines)`
-   **R√¥le :** Convertit le dictionnaire de raies d√©tect√©es en un vecteur num√©rique.
-   **Logique (v0.1.0) :** Pour chaque raie cible, la feature est `1` si un pic a √©t√© trouv√©, et `0` sinon.
-   **Retourne :** Une liste de features (ex: `[1, 0, 1, 1]`).

## <FontAwesomeIcon icon={faBook} /> Exemples & Bonnes Pratiques

Ce snippet montre comment les deux classes travaillent ensemble.

### Traitement d'un seul spectre

```python title="Python title="Workflow pour un spectre"
from src.pipeline.peak_detector import PeakDetector
from src.pipeline.feature_engineering import FeatureEngineer

# Initialisation
peak_detector = PeakDetector()
feature_engineer = FeatureEngineer()

# ... supposons que wavelength et flux_normalized sont disponibles ...

# D√©tection et matching des raies
matched_lines = peak_detector.analyze_spectrum(wavelength, flux_normalized)

# Vectorisation
features_vector = feature_engineer.extract_features(matched_lines)
# R√©sultat possible : [6565.2, 0.0, 3932.8, 3969.1]
```

### Traitement par Lot (Batch)

> Pour le Machine Learning, il est plus efficace de traiter les spectres en lot.

```python title="Traitement par lot optimis√©"
# ... peak_detector et feature_engineer initialis√©s ...
# ... all_spectra est une liste de tuples (wavelength, flux) ...

matched_lines_list = [peak_detector.analyze_spectrum(wl, flux) for wl, flux in all_spectra]

# Utilise la m√©thode optimis√©e pour traiter toute la liste d'un coup
X = feature_engineer.batch_features(matched_lines_list)

# X est maintenant une matrice NumPy de shape (N_spectres, N_features)
print(f"Matrice de features cr√©√©e, shape : {X.shape}")
```

<div className="container" style={{padding: '0', marginTop: '2rem'}}>
<div className="row">
<div className="col col--6">
<Admonition type="tip" title="Bonnes Pratiques" icon="üí°">
<ul>
<li><strong>Normalisation d'abord :</strong> Toujours appliquer le pr√©traitement et la normalisation <em>avant</em> de d√©tecter les pics.</li>
<li><strong>Ajuster la `prominence` :</strong> Pour des spectres tr√®s bruit√©s (faible SNR), envisagez de l'augmenter pour √©viter de d√©tecter le bruit comme des raies.</li>
</ul>
</Admonition>
</div>
<div className="col col--6">
<Admonition type="danger" title="Cas Limites & Erreurs" icon="‚ò¢Ô∏è">
<ul>
<li>Si <strong>aucune raie</strong> n'est trouv√©e pour un spectre, le vecteur de features contiendra uniquement des z√©ros.</li>
<li>Si un spectre est fortement d√©cal√© en longueur d'onde (redshift √©lev√© non corrig√©), le matching pourrait √©chouer.</li>
</ul>
</Admonition>
</div>
</div>
</div>
<div className="card">
<div className="card__header" style={{display: 'flex', alignItems: 'center', gap: '0.5rem'}}>
<FontAwesomeIcon icon={faArrowRight} />
<h3>Prochaine √âtape du Pipeline</h3>
</div>
<div className="card__body">
<p>Une fois le vecteur de features obtenu, il est pr√™t √† √™tre utilis√© pour entra√Æner un mod√®le.</p>
</div>
<div className="card__footer">
<a href="./classifier" className="button button--primary button--block">
‚Üí Voir le Module Classifier
</a>
</div>
</div>